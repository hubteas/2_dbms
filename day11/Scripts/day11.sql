--JOIN
--   여러 테이블에 흩어져 있는 정보 중
--   사용자가 필요한 정보만 가져와서 가상의 테이블처럼 만들고 결과를 보여주는 것.
--
--   정규화를 통해 조회 테이블이 너무 많이 쪼개져 있으면 작업이 불편하기 때문에
--   입력, 수정, 삭제의 성능을 향상시키기 위해서 JOIN을 통해 합친 후 사용한다.
--
--내부 조인(INNER JOIN)
--   조건이 정확히 일치하는 값만 합쳐서 조회
--
--   FROM 테이블명A [INNER] JOIN 테이블명B
--   ON 조건
--
--외부 조인(OUTER JOIN) -> 나중에 알아보자.
--
--SQL 실행순서

SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT * FROM EMPLOYEES;

-- 관계를 맺고 있는 EMP 테이블과 DEPT 테이블 한 번에 조회해보자.
-- 관계를 맺고 있는 테이블들이기 때문에, 등가 조인을 이용하면 효율적이겠다.

-- 행의 갯수가 더 작은 테이블을 선행 테이블로 선정한다.
-- 속도와 성능의 차이 때문!

-- 별칭을 줘서 ON절에서 어느 테이블의 컬럼인지를 구분할 수 있다.
-- 행골라내기를 하고 싶다면 , WHERE 추가 가능
SELECT * 
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
WHERE DNAME = 'SALES';

-- ON절에 논리연산을 추가하여 여러개의 조건을 추가할 수 있다.
SELECT * 
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
AND DNAME = 'SALES';

-- 열 골라내기
SELECT ENAME 이름, SAL 봉급, LOC 근무지, DNAME 부서
FROM DEPT D JOIN EMP E
ON D.DEPTNO = E.DEPTNO
WHERE DNAME = 'SALES';

/*
 * 실습
 * 1. 테이블의 관계를 파악하기
 * 2. 관계를 맺은 테이블이라면, 컬럼 이름들을 확인!
 * 3. 선행 테이블로 삼을 테이블 선택!
 * PLAYER 테이블에서 송종국 선수가 속한 팀의  전화번호 검색하기
 * 송종국, 팀 이름, 팀의 전화번호
 */

SELECT * FROM PLAYER;


SELECT * FROM TEAM;

SELECT PLAYER_NAME, TEAM_NAME, TEL
FROM TEAM T JOIN PLAYER P 
ON T.TEAM_ID = P.TEAM_ID
WHERE PLAYER_NAME = '송종국';


-- JOBS 테이블에서 JOB_ID 로 직원들의 JOB_TITLE, EMAIL, 성, 이름 조회

SELECT * FROM JOBS;
SELECT * FROM EMPLOYEES;

SELECT J.JOB_ID , JOB_TITLE, EMAIL, FIRST_NAME , LAST_NAME
FROM JOBS j JOIN EMPLOYEES e 
ON J.JOB_ID = E.JOB_ID;

SELECT *
FROM JOBS j JOIN EMPLOYEES e 
ON J.JOB_ID = E.JOB_ID;

-- 축구 선수들 중에서 각 팀 별로 키가 가장 큰 선수들의 전체 정보 조회하기

SELECT * FROM PLAYER;

SELECT * FROM TEAM;


SELECT *
FROM (SELECT TEAM_ID , MAX(HEIGHT) 큰키
	FROM PLAYER
	GROUP BY TEAM_ID) T JOIN PLAYER p 
ON T.TEAM_ID = P.TEAM_ID AND T.큰키 = P.HEIGHT;


SELECT *
FROM (SELECT TEAM_ID , MAX(HEIGHT) 큰키
	FROM PLAYER
	GROUP BY TEAM_ID) T JOIN PLAYER p 
ON T.TEAM_ID = P.TEAM_ID AND T.큰키=P.HEIGHT
ORDER BY T.TEAM_ID;

SELECT TEAM_ID , MAX(HEIGHT)
FROM PLAYER
GROUP BY TEAM_ID;

SELECT P.TEAM_ID, M.큰키, P.HEIGHT, P.PLAYER_NAME 
FROM
(
   SELECT TEAM_ID, MAX(HEIGHT) 큰키  
   FROM PLAYER
   GROUP BY TEAM_ID
) M JOIN PLAYER p 
ON M.TEAM_ID = P.TEAM_ID
AND M.큰키 = P.HEIGHT
ORDER BY M.TEAM_ID;

-- 위 문제를 JOIN 없이 풀기
-- (A, B) IN (C, D) : A = C AND B = D
SELECT * FROM PLAYER
WHERE (TEAM_ID, HEIGHT) IN (
   SELECT TEAM_ID, MAX(HEIGHT) 
   FROM PLAYER
   GROUP BY TEAM_ID 
);

SELECT * FROM EMPLOYEES e;


SELECT E1.FIRST_NAME, E2.FIRST_NAME 
FROM EMPLOYEES e1 JOIN EMPLOYEES e2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

SELECT * 
FROM EMPLOYEES e1 JOIN EMPLOYEES e2
ON E1.MANAGER_ID = E2.EMPLOYEE_ID;

CREATE TABLE TBL_GRADE(
	GRADE_NUM NUMBER,
	GRADE_NAME VARCHAR2(1000),
	CONSTRAINT PK_GRADE PRIMARY KEY(GRADE_NUM)
);


CREATE TABLE TBL_USER_LIST(
	USER_NUM NUMBER,
	USER_ID VARCHAR2(1000),
	GRADE_NUM NUMBER,
	CONSTRAINT PK_USER_LIST PRIMARY KEY(USER_NUM),
	CONSTRAINT FK_USER_LIST FOREIGN KEY(GRADE_NUM)
	REFERENCES TBL_GRADE(GRADE_NUM)
);

SELECT * FROM TBL_GRADE;


INSERT INTO TBL_GRADE
VALUES(3,'NORMAL');

INSERT INTO TBL_USER_LIST
VALUES(2,'홍길동',3);

SELECT * FROM TBL_USER_LIST;

SELECT * FROM TBL_GRADE TG JOIN TBL_USER_LIST TUL
ON TG.GRADE_NUM = TUL.GRADE_NUM;

SELECT * FROM TBL_GRADE TG LEFT OUTER JOIN TBL_USER_LIST TUL
ON TG.GRADE_NUM = TUL.GRADE_NUM;

SELECT * FROM TBL_GRADE TG RIGHT OUTER JOIN TBL_USER_LIST TUL
ON TG.GRADE_NUM = TUL.GRADE_NUM;

-- 두 테이블의 모든 행 조회

SELECT * FROM TBL_GRADE TG FULL OUTER JOIN TBL_USER_LIST TUL
ON TG.GRADE_NUM = TUL.GRADE_NUM;

-- 두 테이블의 모든 행 조회


-- CROSS
-- JOIN 할 때 조건이 없을 때 유용하게 사용할 수 있다.
SELECT *
FROM TBL_GRADE tg CROSS JOIN TBL_USER_LIST tul;